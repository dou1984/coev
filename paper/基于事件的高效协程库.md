
基于事件的高效协程方案

作者： 赵蕴山
Date: 2023-10-01
Auther: Zhao Yun Shan
Project: Programming Language C++

# 目的

 c++20协程库是高性能的协程库方案, 但是一直没有流行起来，c++20协程理解起来有难度，开发者需要对其底层逻辑非常清晰，才能写出一个完善的协程过程，完成一个工程需要封装多个协程类，大大增加了开发成本。因此本文提供了一套协程封装实现方法，封装是基于事件驱动的，将协程开发从其他代码中分离出来，开发人员可以开箱即用，非常容易上手，可以快速将现有程序转为协程程序。

# 事件驱动的协程类

现在作者有很多的工程都使用了异步开发，对于这些异步过程每个类改造成协程类开发工作量很大，所以作者设计了一种基于事件驱动的协程库，对于其他开发者来说是非常友好的，不需要做任何封装，大大提升了开发效率。

作者通过c++20协程库封装了几个类awaiter、event、task、async, 它们高度抽象了协程过程，开发者可以将协程与I/O、网络、管道、计时器、异步过程调用等等的代码区分开来。只要在开发流程中，数据未准备好时协程等待，数据准备完成时恢复协程，并继续执行即可。

1.event是最小需求的协程类，只负责事件驱动，它不生成新的coroutine_handler，当等待数据准备时 co_await event 可以立即suspend awaiter协程，当数据准备好时可通过异步的方式resume awaiter协程，event是事件驱动的核心。
2.awaiter是封装的协程类，会创建一个新的coroutine_handler，在awaiter里可以co_await event，当数据准备耗时，可以恢复到awaitr的函数体继续执行， 当awaiter 协程函数体完成时（co_return\co_yield)会resume到调用它的上层awaiter。
3.async是event的集合，用于存储多个event，可用于不同分类的event等待，它用于多个awaiter逐次等待event。
4.task用于同时等待多个awaitr协程时使用，task可以用在同时等待多个独立的流程完成，不同的task组合可以完成复杂的流程。



# event

event是最小需求的协程类，只负责事件驱动，类中的m_awaiting是创建event的awaiter，当数据准备好时会通过m_awaiting恢复到awaiter协程函数体继续执行。

```cpp
struct event final : chain    // chain是一个简化的list
{
  std::atomic_int m_status{INIT};
  std::coroutine_handle<> m_awatier = _nullptr;
  uint64_t m_tid = 0;         // 线程id  
  event(chain *_eventchain);  // 把这个event插入eventchain
  virtual ~event();
  void await_resume();
  bool await_ready() { return m_status == READY; }
  void await_suspend(std::coroutine_handle<> awaiting)；
  void resume();
};
```

# async


evl是用于存储 "event list", 当等待数据时调用wait_for方法，awaiter协程会进入等待状态，当需要恢复协程时，调用resume函数就可以跳转到等待中的awaiter
evlts 是线程安全的 "event list"， 
async是event的集合，为了区分独立的 event 类型， async 可以包含多个event list。 通过位置标记可以获取对应的event list

```cpp



```

awaiter是一个协程封装类，当co_awaiter awaiter时，它会创建一个协程（coroutine_handle)，并分别获得调用者caller awaiter的指针m_awaiting，当awaiter函数体执行完成时，coroutine_handle会销毁并会调用m_awaiter的resume函数，并恢复到调用者的awaiter函数体继续执行。

awaiter函数体里可以等待event事件，使用wait_for方法等待event事件，当event事件完成时，调用resume函数恢复awaiter协程函数体继续执行。
awaiter里也包装了task相关的
awaiter实现也包含了taskevent类，用于同时等待多个awaiter协程的机制task。将taskevent机制和awaiter封装在一起，task机制统一起来，对于开发者来说降低了协程使用难度，只需要使用awaiter即可。

```cpp
struct awaiter final : taskevent      // taskevent用于同时等待多个awaiter协程完成时使用
{
  struct promise_type 
  {   
   int value;   
   awaiter *m_awaiter = nullptr;      // 当前的coroutine_handle对应的awaiter   
   awaiter get_return_object();
   std::suspend_never return_value(int v);
   std::suspend_never yield_value(int v);
  };
  awaiter(std::coroutine_handle<promise_type> h) : m_coroutine(h)
  {
    m_coroutine.promise().m_awaiter = this;
  }
  void resume();                      // 恢复到上层等待中的awaiter协程
  bool done() { return m_coroutine ? m_coroutine.done() : true; }
  bool await_ready() { return m_ready; } 
  void await_suspend(std::coroutine_handle<> awaiting) { m_awaiting = awaiting; }
  auto await_resume() { return m_coroutine ? m_coroutine.promise().value : 0; }
  void destroy();                     // 强制结束一个等待中的awaiter协程。
  std::coroutine_handle<promise_type> m_coroutine = nullptr;  // 当前的coroutine_handler
  std::coroutine_handle<> m_awaiting = nullptr;               // 上层的coroutine_handler
  std::atomic_bool m_ready{false};

};
```

 在awaiter中使用wait_for一个event，wait_for会把event插入event list里，并等待数据及事件触发, 当数据准备完成事件触发时，可以resume event list里的event，event会恢复到等待中的awaiter。

```cpp
async<evl> g_triger;

awaiter co_waiting()
{ 
 co_await wait_for<0>(&g_trigger); // 等待数据准备完成、事件触发
 co_return 0;
}
awaiter co_trigger()
{
 co_await sleep_for(1);       //等待1秒
 resume<0>(g_trigger);  // 数据准备完成、触发事件时，跳转到协程co_waiting
 co_return 0;
}
```

可以启动多个awaiter协程，同时等待event list里的event，当数据准备完成、触发事件时，可以逐次恢复awaiter协程

```cpp
async g_trigger;
awaiter co_waiting_first()
{ 
 co_await wait_for(&g_trigger); 
 co_return 0;
}
awaiter co_waiting_second()
{ 
 co_await wait_for(&g_trigger); 
 co_return 0;
}
void co_trigger()
{
 while(resume(g_trigger));//逐个恢复等待中的awaiter
}
```


可以在awaiter的协程中嵌套awaiter协程, 开发者可以用于封装不同的基础库，然后交给其他开发者并在此基础上在进行封装, 开发者不需要对awaiter协程再次封装。

```cpp
awaiter co_io_read(char* buf, int len)
{
 co_await sleep_for(1);
 int r = async_read_some(buf, len);
 co_return r;
}
awaiter co_read()
{
  char buf[100];
  int r = co_await co_io_read(buf, sizeof(buf));  
  printf("read length %d, content: %s\n", r, buf);
  co_return 0;
}
```

evlts是线程安全的event list， 当然也可以用wait_for函数等待时间，SUPPEND是判断，CALL用户做数据改变，在wait_for调用中变量是收到std::mutex保护的，

```cpp
async<evlts> g_trigger;
awaiter co_thread0() {

}
awaiter co_thread1(){

}
```

wait_for_all 用于同时等待多个awaiter协程完成, 当所有等待的awaiter协程都完成时，wait_for_all会返回。
task是存储taskevent的list，可以存储多个awaiter，当一个awaiter完成时会恢复到wait_for_all中，并判断task是否还有awaiter在运行中，如果已经没有运行中的awaiter了就向上返回。

  ```cpp
 template <class... T>
 awaiter wait_for_all(T &&..._task)
 {
  task w; //task用于存储awaiter
  (w.insert_task(&_task), ...);
  while (!w.empty()) 
   co_await wait_for<EVEvent>(&w);
  co_return 0;
}
awaiter co_wait_complated()
{
  co_await wait_for_all(sleep_for(1), sleep_for(2));
  co_return 0;
}
```

wait_for_any 用于等待多个awaiter协程中任意一个完成, 当某个等待的awaiter协程完成时，wait_for_any就会返回。

```cpp
template <class... T>
awaiter wait_for_any(T &&..._task)
{
  task w;
  (w.insert_task(&_task), ...);
  co_await wait_for<EVEvent>(&w);
  w.destroy();
  co_return 0;
}
awaiter co_wait_incomplated()
{
 co_await wait_for_any(sleep_for(1), sleep_for(2));
}
```

eventchain不是线程安全的，如果在多个线程同时使用eventchain等待event，需要增加线程锁。
同时还有另外一个问题，如果在线程A中等待event，而在线程B恢复event后，awaiter恢复后的代码会在线程B中执行，这是个需要注意的问题。

# 总结

所有的awaiter协程都是通过事件驱动的，当等待一个事件时就将event保存到eventchain里，当事件完成时就resume event，并跳转到等待的awaiter，awaiter完成时可以恢复到上层等待中的awaiter。开发者只需要理解awaiter、event、eventchain及wait_for函数即可，不需要理解promise_type、coroutine_handle等等过程，也不需要根据不同的业务再次封装协程。
这个解决方案可以用于异步的程序转换为协程，因为它是高度抽象的，所以对于文件I/O、网络、管道、甚至业务代码的异步过程都可以转换成协程，这样就可以大大降低了开发难度，并且也符合大多数人的开发思维及习惯。

作者提供了一套完整的实现，并且实现了包含了http、mysqlclient、hiredis的样例，请大家参考。
源码地址为

<https://github.com/dou1984/coev/tree/main/src/coev>
